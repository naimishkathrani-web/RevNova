<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dev1 Day 22: Error Handling & Rollback - RevNova Onboarding</title>
    <link rel="stylesheet" href="../styles.css">
    <style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,sans-serif}.main-content{margin-left:280px;padding:2.5rem}.day-header{background:linear-gradient(135deg,#4facfe 0%,#00f2fe 100%);color:#fff;padding:1.5rem;border-radius:10px;margin-bottom:1rem}.step-card{background:#fff;border:1px solid #e0e0e0;padding:1rem;border-radius:8px;margin-bottom:1rem}.nav-buttons{display:flex;justify-content:space-between;margin-top:1.5rem}</style>
</head>
<body>
    <header>
        <div class="container header-container">
            <div class="nav-left">
                <a href="../index.html" class="logo"><div class="logo-box">RevNova</div></a>
                <nav class="main-nav">
                    <ul>
                        <li><a href="onboarding-home.html" class="active">Onboarding</a></li>
                        <li><a href="../about-revnova.html">About RevNova</a></li>
                        <li><a href="../features.html">Features</a></li>
                        <li><a href="../pricing.html">Pricing</a></li>
                        <li><a href="../RevNovaRequirements/requirements-home.html">RevNova Requirements</a></li>
                        <li><a href="../contact.html">Contact</a></li>
                    </ul>
                </nav>
            </div>
            <div class="header-right">
                <div class="country-selector"><span class="fi fi-us"></span></div>
                <a href="../login.html" class="btn btn-login">Login</a>
            </div>
        </div>
    </header>

    <div class="onboarding-layout">
        <aside class="sidebar">
            <h3>Getting Started</h3>
            <ul>
                <li><a href="onboarding-home.html">Onboarding Home</a></li>
                <li><a href="onboarding-overview.html">Project Overview</a></li>
            </ul>
            
            <h3>Developer 1: Daily Tasks</h3>
            <ul>
                <li class="has-children"><span style="font-weight:600;color:#333;">Week 1: Backend Setup</span>
                    <ul>
                        <li><a href="dev1-day01.html">Day 1</a></li>
                        <li><a href="dev1-day02.html">Day 2</a></li>
                        <li><a href="dev1-day03.html">Day 3</a></li>
                        <li><a href="dev1-day04.html">Day 4</a></li>
                        <li><a href="dev1-day05.html">Day 5</a></li>
                    </ul>
                </li>
                <li class="has-children"><span style="font-weight:600;color:#333;">Week 2: Salesforce Integration</span>
                    <ul>
                        <li><a href="dev1-day06.html">Day 6</a></li>
                        <li><a href="dev1-day07.html">Day 7</a></li>
                        <li><a href="dev1-day08.html">Day 8</a></li>
                        <li><a href="dev1-day09.html">Day 9</a></li>
                        <li><a href="dev1-day10.html">Day 10</a></li>
                    </ul>
                </li>
                <li class="has-children"><span style="font-weight:600;color:#333;">Week 3: Field Mapping API</span>
                    <ul>
                        <li><a href="dev1-day11.html">Day 11</a></li>
                        <li><a href="dev1-day12.html">Day 12</a></li>
                        <li><a href="dev1-day13.html">Day 13</a></li>
                        <li><a href="dev1-day14.html">Day 14</a></li>
                        <li><a href="dev1-day15.html">Day 15</a></li>
                    </ul>
                </li>
                <li class="has-children"><span style="font-weight:600;color:#333;">Week 4: Transformation & Queue</span>
                    <ul>
                        <li><a href="dev1-day16.html">Day 16</a></li>
                        <li><a href="dev1-day17.html">Day 17</a></li>
                        <li><a href="dev1-day18.html">Day 18</a></li>
                        <li><a href="dev1-day19.html">Day 19</a></li>
                        <li><a href="dev1-day20.html">Day 20</a></li>
                    </ul>
                </li>
                <li class="has-children"><span style="font-weight:600;color:#333;">Week 5: Execution & Testing</span>
                    <ul>
                        <li><a href="dev1-day21.html">Day 21</a></li>
                        <li><a href="dev1-day22.html">Day 22</a></li>
                        <li><a href="dev1-day23.html">Day 23</a></li>
                        <li><a href="dev1-day24.html">Day 24</a></li>
                        <li><a href="dev1-day25.html">Day 25</a></li>
                    </ul>
                </li>
            </ul>
        </aside>

        <main class="main-content">
        <div class="day-header"><h1>Day 22: Error Handling & Rollback</h1><p>Developer 1 ‚Äî Backend & Database | Week 5/5</p></div>

        <div class="step-card" style="background:#fffbea;border-left:4px solid #f59e0b;">
            <h2>‚ö†Ô∏è IMPORTANT: Start of Day Checklist</h2>
            <p><strong>Before starting today's work, run these commands:</strong></p>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
cd C:\Dev\RevNovaRepository<br>
git pull origin main
            </div>
            <p>This ensures you have the latest code from your teammates. Always pull before starting work!</p>
        </div>

        <div class="step-card" style="background:#e8f5e9;border-left:4px solid #4caf50;">
            <h2>ü§ñ Copy This Prompt for Your GitHub Copilot</h2>
            <p><strong>Use this enhanced prompt to get step-by-step implementation guidance:</strong></p>
            <div style="background:#f5f5f5;padding:1.5rem;border-radius:6px;margin:1rem 0;border-left:3px solid #4caf50;">
<pre style="white-space:pre-wrap;font-family:monospace;font-size:0.9em;line-height:1.6;margin:0;">
<strong>Day 22 - RevNova Backend Developer - Error Handling & Rollback</strong>

<strong>üéØ REVNOVA OVERVIEW:</strong> SaaS platform automating Salesforce CPQ ‚Üí Revenue Cloud migrations. 7-step wizard with critical error handling at execution stage. Must support rollback for failed migrations to restore original data state.

<strong>üìö DETAILED REQUIREMENTS:</strong>
- Error Handling Strategy: <a href="../RevNovaRequirements/error-handling.html" style="color:#1976d2;text-decoration:underline;" target="_blank">docs/RevNovaRequirements/error-handling.html</a>
- Rollback Procedures: <a href="../RevNovaRequirements/rollback-strategy.html" style="color:#1976d2;text-decoration:underline;" target="_blank">docs/RevNovaRequirements/rollback-strategy.html</a>
- Database Design: <a href="../RevNovaRequirements/database-design.html" style="color:#1976d2;text-decoration:underline;" target="_blank">docs/RevNovaRequirements/database-design.html</a>

<strong>üèóÔ∏è MVP MILESTONE STATUS:</strong> Week 5/5 (target: November 30, 2025 - 18 days remaining)

<strong>TECH STACK:</strong> Node.js 20 + Express + TypeScript + PostgreSQL 16 (ACID transactions) + jsforce (Salesforce Bulk API delete) + Bull queue retry mechanism

<strong>Context from Previous Days:</strong>
- Day 21: Built migration execution API with jsforce Bulk API integration, Bull queue progress tracking, batch loading (200 records/batch), migration_execution_logs table

<strong>TODAY'S GOAL:</strong> Implement comprehensive error handling and rollback mechanisms. Support three rollback scenarios: (1) PostgreSQL transaction rollback for database operations, (2) Salesforce record deletion for partially loaded data, (3) Manual rollback endpoint for user-triggered recovery. Ensure detailed error logging with stack traces and record-level failure tracking.

<strong>TASKS:</strong>
1. <strong>Implement Database Transaction Wrapper</strong>
   - Wrap staging table writes in PostgreSQL transactions using client.query('BEGIN'), client.query('COMMIT'), client.query('ROLLBACK')
   - On any error during transformation: ROLLBACK to clear STG1/STG2 tables
   - Ensure atomic operations: either ALL staging data is written or NONE
   - Update transformation.processor.ts to use transaction wrapper
   - Add try-catch blocks with detailed error logging (error.message, error.stack)

2. <strong>Create Salesforce Rollback Service</strong> (backend/src/services/salesforce-rollback.service.ts)
   - rollbackMigration(migrationId: string): Promise&lt;RollbackResult&gt;
   - Query migration_execution_logs for successfully inserted record IDs
   - Use jsforce Bulk API to delete records: conn.bulk.load('Product2', 'delete', recordIds)
   - Delete in reverse order: PricebookEntry first, then Product2 (respect foreign key constraints)
   - Track rollback progress: { deletedRecords: number, failedDeletes: Array&lt;{id, error}&gt; }
   - Log all rollback actions to migration_rollback_logs table

3. <strong>Add POST /api/migrations/:id/rollback endpoint</strong> (backend/src/routes/migrations.routes.ts)
   - Validate migration exists and has status='FAILED' or 'COMPLETED_WITH_ERRORS' (prevent accidental rollback of successful migrations)
   - Submit Bull queue job: migrationQueue.add('rollback-migration', { migrationId })
   - Update migration status to 'ROLLING_BACK'
   - Return: { jobId, status: 'ROLLING_BACK', message: 'Rollback initiated' }
   - Prevent duplicate rollbacks: check if rollback already in progress

4. <strong>Implement Retry Logic with Exponential Backoff</strong>
   - Update Bull queue job options: attempts: 3, backoff: { type: 'exponential', delay: 2000 }
   - For transient Salesforce errors (connection timeout, rate limits): retry with exponential backoff (2s, 4s, 8s)
   - For permanent errors (invalid field, missing required field): fail immediately, don't retry
   - Distinguish error types using jsforce error codes (INVALID_FIELD, REQUIRED_FIELD_MISSING, CONNECTION_TIMEOUT)

5. <strong>Enhanced Error Logging</strong>
   - Create detailed error logs with: timestamp, migration_id, error_type (VALIDATION, NETWORK, SYSTEM), error_message, stack_trace, affected_records_json
   - Add error severity levels: CRITICAL (stops execution), WARNING (logged but continues), INFO (normal operation logs)
   - Store in migration_error_logs table with searchable JSON fields
   - Implement error aggregation: group similar errors to avoid log spam (e.g., "50 records failed with same validation error")

<strong>ACCEPTANCE CRITERIA:</strong>
‚úÖ Database transactions wrap all staging table operations (BEGIN/COMMIT/ROLLBACK)
‚úÖ SalesforceRollbackService deletes records from target Salesforce using jsforce Bulk API
‚úÖ POST /api/migrations/:id/rollback endpoint validates status and submits Bull job
‚úÖ Bull queue retry logic: 3 attempts with exponential backoff for transient errors
‚úÖ Detailed error logs stored in migration_error_logs table with severity, stack traces, affected records
‚úÖ Rollback logs tracked in migration_rollback_logs table
‚úÖ Migration status state machine enforced: EXECUTING ‚Üí FAILED ‚Üí ROLLING_BACK ‚Üí ROLLED_BACK
‚úÖ Unit tests: rollback service (mock jsforce delete), retry logic (simulate transient errors)

Guide me step-by-step through implementing robust error handling, database transactions, and Salesforce rollback mechanisms.
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>üìã Objective</h2>
            <p>Implement robust error handling, PostgreSQL transaction management, and Salesforce rollback mechanisms to ensure data integrity and support failure recovery scenarios.</p>
        </div>

        <div class="step-card">
            <h2>Step 1: Create Database Transaction Wrapper</h2>
            <p><strong>File:</strong> <code>backend/src/utils/transaction.ts</code></p>
            <h3>Implementation:</h3>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { Pool, PoolClient } from 'pg';
import { logger } from './logger';

export async function withTransaction&lt;T&gt;(
  pool: Pool,
  callback: (client: PoolClient) =&gt; Promise&lt;T&gt;
): Promise&lt;T&gt; {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    logger.info('Transaction started');
    
    const result = await callback(client);
    
    await client.query('COMMIT');
    logger.info('Transaction committed');
    
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('Transaction rolled back due to error:', error);
    throw error;
  } finally {
    client.release();
  }
}
</pre>
            </div>
            
            <h3>Update Transformation Processor to Use Transactions:</h3>
            <p><strong>File:</strong> <code>backend/src/jobs/transformation.processor.ts</code></p>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { withTransaction } from '../utils/transaction';

export async function processTransformation(job: Job) {
  const { migrationId } = job.data;
  
  try {
    await withTransaction(db, async (client) =&gt; {
      // Clear existing staging data for this migration
      await client.query('DELETE FROM STG1_PRODUCTS WHERE migration_id = $1', [migrationId]);
      await client.query('DELETE FROM STG1_PRICEBOOKS WHERE migration_id = $1', [migrationId]);
      await client.query('DELETE FROM STG2_PRODUCTS WHERE migration_id = $1', [migrationId]);
      await client.query('DELETE FROM STG2_PRICEBOOKS WHERE migration_id = $1', [migrationId]);
      
      // Apply transformations and insert into staging tables
      const transformedProducts = await transformProducts(migrationId);
      
      for (const product of transformedProducts) {
        await client.query(`
          INSERT INTO STG1_PRODUCTS (migration_id, product_code, product_name, ...)
          VALUES ($1, $2, $3, ...)
        `, [migrationId, product.code, product.name, ...]);
      }
      
      // All inserts succeed or all fail together (ACID transaction)
    });
    
    // Update migration status on success
    await db.query(
      'UPDATE migrations SET status = $1, updated_at = NOW() WHERE id = $2',
      ['TRANSFORMED', migrationId]
    );
  } catch (error) {
    logger.error(`Transformation failed for ${migrationId}:`, error);
    
    await db.query(
      'UPDATE migrations SET status = $1, error_message = $2 WHERE id = $3',
      ['FAILED', error.message, migrationId]
    );
    
    throw error;
  }
}
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 2: Create Salesforce Rollback Service</h2>
            <p><strong>File:</strong> <code>backend/src/services/salesforce-rollback.service.ts</code></p>
            <h3>Implementation:</h3>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { Pool } from 'pg';
import jsforce from 'jsforce';
import { logger } from '../utils/logger';

export interface RollbackResult {
  deletedRecords: number;
  failedDeletes: Array&lt;{ id: string; error: string }&gt;;
}

export class SalesforceRollbackService {
  constructor(
    private db: Pool,
    private connection: jsforce.Connection
  ) {}

  async rollbackMigration(migrationId: string): Promise&lt;RollbackResult&gt; {
    logger.info(`Starting rollback for migration ${migrationId}`);
    
    // Get successfully inserted record IDs from execution logs
    const logsResult = await this.db.query(
      'SELECT errors_json FROM migration_execution_logs WHERE migration_id = $1 ORDER BY created_at DESC LIMIT 1',
      [migrationId]
    );
    
    if (logsResult.rows.length === 0) {
      logger.warn(`No execution logs found for migration ${migrationId}`);
      return { deletedRecords: 0, failedDeletes: [] };
    }
    
    const executionErrors = logsResult.rows[0].errors_json || [];
    
    // Get all record IDs that were successfully inserted (not in errors list)
    const allRecords = await this.getInsertedRecordIds(migrationId);
    const errorRecordIds = new Set(executionErrors.map((e: any) =&gt; e.recordId));
    const successfulRecordIds = allRecords.filter(id =&gt; !errorRecordIds.has(id));
    
    let deletedCount = 0;
    const failedDeletes: Array&lt;{ id: string; error: string }&gt; = [];
    
    // Delete PricebookEntry first (foreign key constraint)
    const pricebookIds = successfulRecordIds.filter(id =&gt; id.startsWith('pbe-'));
    if (pricebookIds.length &gt; 0) {
      const pbeResults = await this.deleteBatch('PricebookEntry', pricebookIds);
      deletedCount += pbeResults.deletedCount;
      failedDeletes.push(...pbeResults.failedDeletes);
    }
    
    // Delete Product2 records
    const productIds = successfulRecordIds.filter(id =&gt; id.startsWith('prod-'));
    if (productIds.length &gt; 0) {
      const prodResults = await this.deleteBatch('Product2', productIds);
      deletedCount += prodResults.deletedCount;
      failedDeletes.push(...prodResults.failedDeletes);
    }
    
    // Log rollback results
    await this.db.query(`
      INSERT INTO migration_rollback_logs 
      (migration_id, deleted_records, failed_deletes_json, created_at)
      VALUES ($1, $2, $3, NOW())
    `, [migrationId, deletedCount, JSON.stringify(failedDeletes)]);
    
    logger.info(`Rollback complete for ${migrationId}: ${deletedCount} records deleted`);
    
    return { deletedRecords: deletedCount, failedDeletes };
  }

  private async deleteBatch(
    sobjectType: string,
    recordIds: string[]
  ): Promise&lt;{ deletedCount: number; failedDeletes: Array&lt;{ id: string; error: string }&gt; }&gt; {
    const BATCH_SIZE = 200;
    let deletedCount = 0;
    const failedDeletes: Array&lt;{ id: string; error: string }&gt; = [];
    
    for (let i = 0; i &lt; recordIds.length; i += BATCH_SIZE) {
      const batch = recordIds.slice(i, i + BATCH_SIZE);
      
      try {
        logger.info(`Deleting batch of ${batch.length} ${sobjectType} records`);
        const results = await this.connection.bulk.load(sobjectType, 'delete', batch.map(id =&gt; ({ Id: id })));
        
        results.forEach((result: any, idx: number) =&gt; {
          if (result.success) {
            deletedCount++;
          } else {
            failedDeletes.push({
              id: batch[idx],
              error: result.errors.join(', ')
            });
          }
        });
      } catch (error) {
        logger.error(`Delete batch failed:`, error);
        batch.forEach(id =&gt; {
          failedDeletes.push({ id, error: error.message });
        });
      }
    }
    
    return { deletedCount, failedDeletes };
  }

  private async getInsertedRecordIds(migrationId: string): Promise&lt;string[]&gt; {
    // Query staging tables for record IDs that were inserted
    const productResult = await this.db.query(
      'SELECT salesforce_id FROM STG1_PRODUCTS WHERE migration_id = $1 AND salesforce_id IS NOT NULL',
      [migrationId]
    );
    
    const pricebookResult = await this.db.query(
      'SELECT salesforce_id FROM STG1_PRICEBOOKS WHERE migration_id = $1 AND salesforce_id IS NOT NULL',
      [migrationId]
    );
    
    return [
      ...productResult.rows.map(r =&gt; r.salesforce_id),
      ...pricebookResult.rows.map(r =&gt; r.salesforce_id)
    ];
  }
}
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 3: Create POST /api/migrations/:id/rollback Endpoint</h2>
            <p><strong>File:</strong> <code>backend/src/routes/migrations.routes.ts</code></p>
            <h3>Implementation:</h3>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
router.post('/:id/rollback', async (req: Request, res: Response) =&gt; {
  const { id } = req.params;
  
  try {
    // Validate migration exists and can be rolled back
    const result = await db.query(
      'SELECT status FROM migrations WHERE id = $1',
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Migration not found' });
    }
    
    const migration = result.rows[0];
    const allowedStatuses = ['FAILED', 'COMPLETED_WITH_ERRORS'];
    
    if (!allowedStatuses.includes(migration.status)) {
      return res.status(400).json({ 
        error: `Cannot rollback migration with status ${migration.status}. Must be FAILED or COMPLETED_WITH_ERRORS.` 
      });
    }
    
    // Check if rollback already in progress
    if (migration.status === 'ROLLING_BACK') {
      return res.status(409).json({ error: 'Rollback already in progress' });
    }
    
    // Submit Bull queue job for rollback
    const job = await migrationQueue.add('rollback-migration', {
      migrationId: id
    });
    
    // Update migration status
    await db.query(
      'UPDATE migrations SET status = $1, updated_at = NOW() WHERE id = $2',
      ['ROLLING_BACK', id]
    );
    
    logger.info(`Migration rollback started: ${id} (Job ID: ${job.id})`);
    
    res.json({
      jobId: job.id,
      status: 'ROLLING_BACK',
      message: 'Rollback initiated'
    });
  } catch (error) {
    logger.error('Rollback initiation error:', error);
    res.status(500).json({ error: 'Failed to start rollback' });
  }
});
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 4: Implement Bull Queue Rollback Processor</h2>
            <p><strong>File:</strong> <code>backend/src/jobs/rollback.processor.ts</code></p>
            <h3>Implementation:</h3>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { Job } from 'bull';
import { db } from '../config/database';
import { getSalesforceConnection } from '../services/salesforce.service';
import { SalesforceRollbackService } from '../services/salesforce-rollback.service';
import { logger } from '../utils/logger';

export async function processRollback(job: Job) {
  const { migrationId } = job.data;
  
  logger.info(`Processing rollback job ${job.id} for migration ${migrationId}`);
  
  try {
    // Get Salesforce connection
    const connection = await getSalesforceConnection(migrationId);
    
    // Create rollback service
    const rollbackService = new SalesforceRollbackService(db, connection);
    
    // Execute rollback
    const result = await rollbackService.rollbackMigration(migrationId);
    
    // Update migration status
    const finalStatus = result.failedDeletes.length === 0 ? 'ROLLED_BACK' : 'ROLLBACK_PARTIAL';
    await db.query(
      'UPDATE migrations SET status = $1, updated_at = NOW() WHERE id = $2',
      [finalStatus, migrationId]
    );
    
    logger.info(`Rollback complete for ${migrationId}: ${result.deletedRecords} deleted, ${result.failedDeletes.length} failed`);
    
    return result;
  } catch (error) {
    logger.error(`Rollback failed for ${migrationId}:`, error);
    
    await db.query(
      'UPDATE migrations SET status = $1, error_message = $2 WHERE id = $3',
      ['ROLLBACK_FAILED', error.message, migrationId]
    );
    
    throw error;
  }
}

// Register processor with retry logic
migrationQueue.process('rollback-migration', {
  concurrency: 3,
  attempts: 3,
  backoff: {
    type: 'exponential',
    delay: 2000 // 2s, 4s, 8s
  }
}, processRollback);
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 5: Create Database Migrations for Rollback Tables</h2>
            <p><strong>File:</strong> <code>backend/migrations/008_create_rollback_logs.sql</code></p>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
CREATE TABLE migration_rollback_logs (
  id SERIAL PRIMARY KEY,
  migration_id VARCHAR(255) NOT NULL,
  deleted_records INTEGER NOT NULL,
  failed_deletes_json JSONB,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (migration_id) REFERENCES migrations(id) ON DELETE CASCADE
);

CREATE TABLE migration_error_logs (
  id SERIAL PRIMARY KEY,
  migration_id VARCHAR(255) NOT NULL,
  error_type VARCHAR(50) NOT NULL, -- VALIDATION, NETWORK, SYSTEM
  severity VARCHAR(20) NOT NULL, -- CRITICAL, WARNING, INFO
  error_message TEXT NOT NULL,
  stack_trace TEXT,
  affected_records_json JSONB,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (migration_id) REFERENCES migrations(id) ON DELETE CASCADE
);

CREATE INDEX idx_rollback_logs_migration ON migration_rollback_logs(migration_id);
CREATE INDEX idx_error_logs_migration ON migration_error_logs(migration_id);
CREATE INDEX idx_error_logs_severity ON migration_error_logs(severity);
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 6: Implement Enhanced Error Logging</h2>
            <p><strong>File:</strong> <code>backend/src/utils/error-logger.ts</code></p>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { Pool } from 'pg';
import { logger } from './logger';

type ErrorType = 'VALIDATION' | 'NETWORK' | 'SYSTEM';
type Severity = 'CRITICAL' | 'WARNING' | 'INFO';

export async function logMigrationError(
  db: Pool,
  migrationId: string,
  errorType: ErrorType,
  severity: Severity,
  error: Error,
  affectedRecords?: any[]
) {
  try {
    await db.query(`
      INSERT INTO migration_error_logs 
      (migration_id, error_type, severity, error_message, stack_trace, affected_records_json, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
    `, [
      migrationId,
      errorType,
      severity,
      error.message,
      error.stack,
      affectedRecords ? JSON.stringify(affectedRecords) : null
    ]);
    
    logger.error(`[${severity}] ${errorType} error in migration ${migrationId}:`, error.message);
  } catch (logError) {
    logger.error('Failed to log migration error:', logError);
  }
}

// Helper to distinguish Salesforce error types
export function getSalesforceErrorType(error: any): ErrorType {
  const errorCode = error.errorCode || '';
  
  if (['INVALID_FIELD', 'REQUIRED_FIELD_MISSING', 'FIELD_CUSTOM_VALIDATION_EXCEPTION'].includes(errorCode)) {
    return 'VALIDATION';
  }
  
  if (['CONNECTION_ERROR', 'TIMEOUT', 'REQUEST_LIMIT_EXCEEDED'].includes(errorCode)) {
    return 'NETWORK';
  }
  
  return 'SYSTEM';
}
</pre>
            </div>
        </div>

        <div class="step-card">
            <h2>Step 7: Write Unit Tests</h2>
            <p><strong>File:</strong> <code>backend/tests/salesforce-rollback.test.ts</code></p>
            <div style="background:#2d2d2d;color:#f8f8f2;padding:1rem;border-radius:6px;font-family:monospace;margin:1rem 0;">
<pre style="margin:0;white-space:pre-wrap;">
import { SalesforceRollbackService } from '../src/services/salesforce-rollback.service';

describe('SalesforceRollbackService', () =&gt; {
  let service: SalesforceRollbackService;
  let mockDb: any;
  let mockConnection: any;
  
  beforeEach(() =&gt; {
    mockDb = {
      query: jest.fn()
    };
    
    mockConnection = {
      bulk: {
        load: jest.fn()
      }
    };
    
    service = new SalesforceRollbackService(mockDb, mockConnection);
  });
  
  test('should rollback migration successfully', async () =&gt; {
    mockDb.query
      .mockResolvedValueOnce({ rows: [{ errors_json: [] }] }) // execution logs
      .mockResolvedValueOnce({ rows: [{ salesforce_id: 'prod-1' }] }) // products
      .mockResolvedValueOnce({ rows: [] }); // pricebooks
    
    mockConnection.bulk.load.mockResolvedValue([
      { success: true, id: 'prod-1' }
    ]);
    
    const result = await service.rollbackMigration('mig-123');
    
    expect(result.deletedRecords).toBe(1);
    expect(result.failedDeletes.length).toBe(0);
    expect(mockConnection.bulk.load).toHaveBeenCalledWith('Product2', 'delete', expect.any(Array));
  });
  
  test('should handle delete failures gracefully', async () =&gt; {
    mockDb.query
      .mockResolvedValueOnce({ rows: [{ errors_json: [] }] })
      .mockResolvedValueOnce({ rows: [{ salesforce_id: 'prod-1' }] })
      .mockResolvedValueOnce({ rows: [] });
    
    mockConnection.bulk.load.mockResolvedValue([
      { success: false, errors: ['Record is locked'] }
    ]);
    
    const result = await service.rollbackMigration('mig-123');
    
    expect(result.failedDeletes.length).toBe(1);
    expect(result.failedDeletes[0].error).toContain('Record is locked');
  });
});
</pre>
            </div>
        </div>

        <div class="step-card" style="background:#e3f2fd;border-left:4px solid #2196f3;">
            <h2>‚úÖ Acceptance Criteria</h2>
            <ul style="line-height:1.8;">
                <li>‚úÖ Database transactions wrap staging table operations (withTransaction helper)</li>
                <li>‚úÖ SalesforceRollbackService deletes records using jsforce Bulk API (delete operation)</li>
                <li>‚úÖ POST /api/migrations/:id/rollback validates status (must be FAILED or COMPLETED_WITH_ERRORS)</li>
                <li>‚úÖ Bull queue retry logic: 3 attempts, exponential backoff (2s, 4s, 8s)</li>
                <li>‚úÖ Detailed error logs in migration_error_logs table (type, severity, stack trace, affected records)</li>
                <li>‚úÖ Rollback results tracked in migration_rollback_logs table</li>
                <li>‚úÖ Migration status state machine: EXECUTING ‚Üí FAILED ‚Üí ROLLING_BACK ‚Üí ROLLED_BACK</li>
                <li>‚úÖ Unit tests cover rollback success and failure scenarios</li>
            </ul>
        </div>

        <div class="step-card" style="background:#fff3cd;border-left:4px solid #ffc107;">
            <h2>üí° Testing Tips</h2>
            <ul style="line-height:1.8;">
                <li>Test rollback with a small failed migration first (intentionally cause validation errors)</li>
                <li>Verify records are deleted from Salesforce Sandbox (query before/after rollback)</li>
                <li>Check migration_rollback_logs and migration_error_logs tables for detailed results</li>
                <li>Test duplicate rollback prevention (try calling /api/migrations/:id/rollback twice)</li>
                <li>Simulate transient errors (network timeout) to test retry logic</li>
            </ul>
        </div>
        <div class="nav-buttons"><a href="dev1-day21.html" class="nav-btn back">‚Üê Back to Day 21</a><a href="dev1-day23.html" class="nav-btn next">Next: Day 23 ‚Üí</a></div>
            </main>
    </div>
    <script src="../script.js"></script>
</body>
</html>
